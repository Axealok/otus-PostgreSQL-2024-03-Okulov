# Блокировки

## Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
```
locks=# ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM
locks=# ALTER SYSTEM SET deadlock_timeout = 200;
ALTER SYSTEM
locks=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 строка)

```

```
2024-05-07 11:49:50.453 +05 [349422] СООБЩЕНИЕ:  процесс 349422 продолжает ожидать в режиме ShareLock блокировку "транзакция 1099646" в течение 200.221 мс
2024-05-07 11:49:50.453 +05 [349422] ПОДРОБНОСТИ:  Process holding the lock: 349595. Wait queue: 349422.
2024-05-07 11:49:50.453 +05 [349422] КОНТЕКСТ:  при изменении кортежа (0,5) в отношении "accounts"
2024-05-07 11:49:50.453 +05 [349422] ОПЕРАТОР:  UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
2024-05-07 11:50:23.123 +05 [349422] СООБЩЕНИЕ:  процесс 349422 получил в режиме ShareLock блокировку "транзакция 1099646" через 32870.332 мс
2024-05-07 11:50:23.123 +05 [349422] КОНТЕКСТ:  при изменении кортежа (0,5) в отношении "accounts"
2024-05-07 11:50:23.123 +05 [349422] ОПЕРАТОР:  UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;


```

## Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

## Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
## Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
